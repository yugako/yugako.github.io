{"version":3,"sources":["webpack:///./node_modules/vuefire/dist/vuefire.esm.js"],"names":["createSnapshot","doc","Object","defineProperty","data","value","id","isObject","o","isTimestamp","toDate","isRef","onSnapshot","extractRefs","oldDoc","path","result","idDescriptor","getOwnPropertyDescriptor","enumerable","keys","reduce","tot","key","ref","Array","isArray","length","fill","Date","longitude","latitude","callOnceWithArg","fn","argFn","called","walkGet","obj","split","target","walkSet","pop","splice","unsubscribeAll","subs","sub","unsub","subscribeToRefs","options","refs","depth","ops","resolve","refKeys","missingKeys","filter","refKey","indexOf","forEach","maxRefDepth","resolvedCount","totalToResolve","validResolves","create","deepResolve","docPath","subscribeToDocument","bind","bindCollection","vm","collection","reject","isResolved","array","set","originalResolve","arraySubs","change","added","newIndex","snapshot","ref$1","add","modified","oldIndex","oldData","remove","removed","unbind","docChanges","count","expectedItems","validDocs","dict","_","c","type","updateDataFromDocumentSnapshot","exists","bindDocument","document","index","Promise","where","_firestoreUnbinds","install","Vue","strategies","config","optionMergeStrategies","firestore","provide","mixin","created","this$1","this","$options","$firestoreRefs","call","$bind","beforeDestroy","subKey","prototype","$unbind","promise","__webpack_exports__"],"mappings":"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","file":"src/assets/js/chunk-vendors~8fe9f352.1848029f.js","sourcesContent":["/*!\n * vuefire v2.0.0-alpha.20\n * (c) 2018 Eduardo San Martin Morote\n * Released under the MIT License.\n */\n/**\n * @typedef {firebase.firestore.DocumentReference | firebase.firestore.CollectionReference} Reference\n */\n/**\n *\n * @param {firebase.firestore.DocumentSnapshot} doc\n * @return {DocumentData}\n */\nfunction createSnapshot (doc) {\n  // defaults everything to false, so no need to set\n  return Object.defineProperty(doc.data(), 'id', {\n    value: doc.id\n  })\n}\n\n/**\n *\n * @param {any} o\n * @returns {boolean}\n */\nfunction isObject (o) {\n  return o && typeof o === 'object'\n}\n\n/**\n *\n * @param {any} o\n * should be o is Date https://github.com/Microsoft/TypeScript/issues/26297\n * @returns {boolean}\n */\nfunction isTimestamp (o) {\n  return o.toDate\n}\n\n/**\n *\n * @param {*} o\n * @returns {boolean}\n */\nfunction isRef (o) {\n  return o && o.onSnapshot\n}\n\n/**\n *\n * @param {firebase.firestore.DocumentData} doc\n * @param {firebase.firestore.DocumentData} [oldDoc]\n * @param {string} [path]\n * @param {[firebase.firestore.DocumentData, Record<string, Reference>]} result\n * @returns {[firebase.firestore.DocumentData, Record<string, Reference>]}\n */\nfunction extractRefs (doc, oldDoc, path, result) {\n  if ( oldDoc === void 0 ) oldDoc = {};\n  if ( path === void 0 ) path = '';\n  if ( result === void 0 ) result = [{}, {}];\n\n  // must be set here because walkGet can return null or undefined\n  oldDoc = oldDoc || {};\n  var idDescriptor = Object.getOwnPropertyDescriptor(doc, 'id');\n  if (idDescriptor && !idDescriptor.enumerable) {\n    Object.defineProperty(result[0], 'id', idDescriptor);\n  }\n  return Object.keys(doc).reduce(function (tot, key) {\n    var ref = doc[key];\n    // if it's a ref\n    if (isRef(ref)) {\n      tot[0][key] = oldDoc[key] || ref.path;\n      // TODO handle subpathes?\n      tot[1][path + key] = ref;\n    } else if (Array.isArray(ref)) {\n      // TODO handle array\n      tot[0][key] = Array(ref.length).fill(null);\n      extractRefs(ref, oldDoc[key], path + key + '.', [tot[0][key], tot[1]]);\n    } else if (\n      ref == null ||\n      // Firestore < 4.13\n      ref instanceof Date ||\n      isTimestamp(ref) ||\n      (ref.longitude && ref.latitude) // GeoPoint\n    ) {\n      tot[0][key] = ref;\n    } else if (isObject(ref)) {\n      tot[0][key] = {};\n      extractRefs(ref, oldDoc[key], path + key + '.', [tot[0][key], tot[1]]);\n    } else {\n      tot[0][key] = ref;\n    }\n    return tot\n  }, result)\n}\n\n/**\n * @template T any\n * @template K any\n * @param {(arg: T) => K} fn\n * @param {() => T} argFn\n * @returns {() => K | undefined}\n */\nfunction callOnceWithArg (fn, argFn) {\n  /** @type {boolean | undefined} */\n  var called;\n  return function () {\n    if (!called) {\n      called = true;\n      return fn(argFn())\n    }\n  }\n}\n\n/**\n *\n * @param {Record<string, any>} obj\n * @param {string} path\n * @returns {any}\n */\nfunction walkGet (obj, path) {\n  return path.split('.').reduce(function (target, key) { return target[key]; }, obj)\n}\n\n/**\n *\n * @param {Record<string, any>} obj\n * @param {string} path\n * @param {any} value\n * @returns\n */\nfunction walkSet (obj, path, value) {\n  // path can be a number\n  var keys = ('' + path).split('.');\n  var key = keys.pop();\n  var target = keys.reduce(function (target, key) { return target[key]; }, obj);\n  return target.splice ? target.splice(key, 1, value) : (target[key] = value)\n}\n\nfunction unsubscribeAll (subs) {\n  for (var sub in subs) {\n    subs[sub].unsub();\n  }\n}\n\n// NOTE not convinced by the naming of subscribeToRefs and subscribeToDocument\n// first one is calling the other on every ref and subscribeToDocument may call\n// updateDataFromDocumentSnapshot which may call subscribeToRefs as well\nfunction subscribeToRefs (ref, options) {\n  var subs = ref.subs;\n  var refs = ref.refs;\n  var target = ref.target;\n  var path = ref.path;\n  var data = ref.data;\n  var depth = ref.depth;\n  var ops = ref.ops;\n  var resolve = ref.resolve;\n\n  var refKeys = Object.keys(refs);\n  var missingKeys = Object.keys(subs).filter(function (refKey) { return refKeys.indexOf(refKey) < 0; });\n  // unbind keys that are no longer there\n  missingKeys.forEach(function (refKey) {\n    subs[refKey].unsub();\n    delete subs[refKey];\n  });\n  if (!refKeys.length || ++depth > options.maxRefDepth) { return resolve(path) }\n\n  var resolvedCount = 0;\n  var totalToResolve = refKeys.length;\n  var validResolves = Object.create(null);\n  function deepResolve (key) {\n    if (key in validResolves) {\n      if (++resolvedCount >= totalToResolve) { resolve(path); }\n    }\n  }\n\n  refKeys.forEach(function (refKey) {\n    var sub = subs[refKey];\n    var ref = refs[refKey];\n    var docPath = path + \".\" + refKey;\n\n    validResolves[docPath] = true;\n\n    // unsubscribe if bound to a different ref\n    if (sub) {\n      if (sub.path !== ref.path) { sub.unsub(); }\n      // if has already be bound and as we always walk the objects, it will work\n      else { return }\n    }\n\n    subs[refKey] = {\n      unsub: subscribeToDocument(\n        {\n          ref: ref,\n          target: target,\n          path: docPath,\n          depth: depth,\n          ops: ops,\n          resolve: deepResolve.bind(null, docPath)\n        },\n        options\n      ),\n      path: ref.path\n    };\n  });\n}\n\nfunction bindCollection (\n  ref,\n  options\n) {\n  var vm = ref.vm;\n  var key = ref.key;\n  var collection = ref.collection;\n  var ops = ref.ops;\n  var resolve = ref.resolve;\n  var reject = ref.reject;\n  if ( options === void 0 ) options = { maxRefDepth: 2 };\n\n  // TODO support pathes? nested.obj.list (walkSet)\n  // NOTE use ops object\n  var array = ops.set(vm, key, []);\n  // const array = (vm[key] = [])\n  var originalResolve = resolve;\n  var isResolved;\n\n  // contain ref subscriptions of objects\n  // arraySubs is a mirror of array\n  var arraySubs = [];\n\n  var change = {\n    added: function (ref) {\n      var newIndex = ref.newIndex;\n      var doc = ref.doc;\n\n      arraySubs.splice(newIndex, 0, Object.create(null));\n      var subs = arraySubs[newIndex];\n      var snapshot = createSnapshot(doc);\n      var ref$1 = extractRefs(snapshot);\n      var data = ref$1[0];\n      var refs = ref$1[1];\n      // NOTE use ops\n      ops.add(array, newIndex, data);\n      // array.splice(newIndex, 0, data)\n      subscribeToRefs(\n        {\n          data: data,\n          refs: refs,\n          subs: subs,\n          target: array,\n          path: newIndex,\n          depth: 0,\n          ops: ops,\n          resolve: resolve.bind(null, doc)\n        },\n        options\n      );\n    },\n    modified: function (ref) {\n      var oldIndex = ref.oldIndex;\n      var newIndex = ref.newIndex;\n      var doc = ref.doc;\n\n      var subs = arraySubs.splice(oldIndex, 1)[0];\n      arraySubs.splice(newIndex, 0, subs);\n      // NOTE use ops\n      var oldData = ops.remove(array, oldIndex)[0];\n      // const oldData = array.splice(oldIndex, 1)[0]\n      var snapshot = createSnapshot(doc);\n      var ref$1 = extractRefs(snapshot, oldData);\n      var data = ref$1[0];\n      var refs = ref$1[1];\n      // NOTE use ops\n      ops.add(array, newIndex, data);\n      // array.splice(newIndex, 0, data)\n      subscribeToRefs(\n        {\n          data: data,\n          refs: refs,\n          subs: subs,\n          ops: ops,\n          target: array,\n          path: newIndex,\n          depth: 0,\n          resolve: resolve\n        },\n        options\n      );\n    },\n    removed: function (ref) {\n      var oldIndex = ref.oldIndex;\n\n      // NOTE use ops\n      ops.remove(array, oldIndex);\n      // array.splice(oldIndex, 1)\n      unsubscribeAll(arraySubs.splice(oldIndex, 1)[0]);\n    }\n  };\n\n  var unbind = collection.onSnapshot(function (ref) {\n    // console.log('pending', metadata.hasPendingWrites)\n    // docs.forEach(d => console.log('doc', d, '\\n', 'data', d.data()))\n    // NOTE this will only be triggered once and it will be with all the documents\n    // from the query appearing as added\n    // (https://firebase.google.com/docs/firestore/query-data/listen#view_changes_between_snapshots)\n    var docChanges = typeof ref.docChanges === 'function' ? ref.docChanges() : ref.docChanges;\n\n    if (!isResolved && docChanges.length) {\n      // isResolved is only meant to make sure we do the check only once\n      isResolved = true;\n      var count = 0;\n      var expectedItems = docChanges.length;\n      var validDocs = docChanges.reduce(function (dict, ref) {\n        var doc = ref.doc;\n\n        dict[doc.id] = false;\n        return dict\n      }, Object.create(null));\n      resolve = function (ref) {\n        var id = ref.id;\n\n        if (id in validDocs) {\n          if (++count >= expectedItems) {\n            originalResolve(vm[key]);\n            // reset resolve to noop\n            resolve = function (_) {};\n          }\n        }\n      };\n    }\n    docChanges.forEach(function (c) {\n      change[c.type](c);\n    });\n\n    // resolves when array is empty\n    if (!docChanges.length) { resolve(); }\n  }, reject);\n\n  return function () {\n    unbind();\n    arraySubs.forEach(unsubscribeAll);\n  }\n}\n\nfunction updateDataFromDocumentSnapshot (\n  ref,\n  options\n) {\n  var snapshot = ref.snapshot;\n  var target = ref.target;\n  var path = ref.path;\n  var subs = ref.subs;\n  var ops = ref.ops;\n  var depth = ref.depth; if ( depth === void 0 ) depth = 0;\n  var resolve = ref.resolve;\n  if ( options === void 0 ) options = { maxRefDepth: 2 };\n\n  var ref$1 = extractRefs(snapshot, walkGet(target, path));\n  var data = ref$1[0];\n  var refs = ref$1[1];\n  // NOTE use ops\n  ops.set(target, path, data);\n  // walkSet(target, path, data)\n  subscribeToRefs(\n    {\n      data: data,\n      subs: subs,\n      refs: refs,\n      target: target,\n      path: path,\n      ops: ops,\n      depth: depth,\n      resolve: resolve\n    },\n    options\n  );\n}\n\nfunction subscribeToDocument (ref$1, options) {\n  var ref = ref$1.ref;\n  var target = ref$1.target;\n  var path = ref$1.path;\n  var depth = ref$1.depth;\n  var resolve = ref$1.resolve;\n  var ops = ref$1.ops;\n\n  var subs = Object.create(null);\n  var unbind = ref.onSnapshot(function (doc) {\n    if (doc.exists) {\n      updateDataFromDocumentSnapshot(\n        {\n          snapshot: createSnapshot(doc),\n          target: target,\n          path: path,\n          ops: ops,\n          subs: subs,\n          depth: depth,\n          resolve: resolve\n        },\n        options\n      );\n    } else {\n      // NOTE use ops\n      ops.set(target, path, null);\n      // walkSet(target, path, null)\n      resolve(path);\n    }\n  });\n\n  return function () {\n    unbind();\n    unsubscribeAll(subs);\n  }\n}\n\n/* TODO do not use an object\n *\n * @param {*} vm\n * @param {string} key\n * @param {firebase.firestore.DocumentReference} document\n * @param {*} resolve\n * @param {*} reject\n * @param {OperationsType<any>} ops\n * @param {*} options\n */\nfunction bindDocument (ref, options) {\n  var vm = ref.vm;\n  var key = ref.key;\n  var document = ref.document;\n  var resolve = ref.resolve;\n  var reject = ref.reject;\n  var ops = ref.ops;\n\n  // TODO warning check if key exists?\n  // const boundRefs = Object.create(null)\n\n  var subs = Object.create(null);\n  // bind here the function so it can be resolved anywhere\n  // this is specially useful for refs\n  // TODO use walkGet?\n  resolve = callOnceWithArg(resolve, function () { return vm[key]; });\n  var unbind = document.onSnapshot(function (doc) {\n    if (doc.exists) {\n      updateDataFromDocumentSnapshot(\n        {\n          snapshot: createSnapshot(doc),\n          target: vm,\n          path: key,\n          subs: subs,\n          ops: ops,\n          resolve: resolve\n        },\n        options\n      );\n    } else {\n      resolve();\n    }\n  }, reject);\n\n  return function () {\n    unbind();\n    unsubscribeAll(subs);\n  }\n}\n\nvar ops = {\n  set: function (target, key, value) { return walkSet(target, key, value); },\n  add: function (array, index, data) { return array.splice(index, 0, data); },\n  remove: function (array, index) { return array.splice(index, 1); }\n};\n\nfunction bind (ref$1, options) {\n  var vm = ref$1.vm;\n  var key = ref$1.key;\n  var ref = ref$1.ref;\n  var ops = ref$1.ops;\n  if ( options === void 0 ) options = { maxRefDepth: 2 };\n\n  return new Promise(function (resolve, reject) {\n    var unbind;\n    if (ref.where) {\n      unbind = bindCollection(\n        {\n          vm: vm,\n          key: key,\n          ops: ops,\n          collection: ref,\n          resolve: resolve,\n          reject: reject\n        },\n        options\n      );\n    } else {\n      unbind = bindDocument(\n        {\n          vm: vm,\n          key: key,\n          ops: ops,\n          document: ref,\n          resolve: resolve,\n          reject: reject\n        },\n        options\n      );\n    }\n    vm._firestoreUnbinds[key] = unbind;\n  })\n}\n\nfunction install (Vue) {\n  var strategies = Vue.config.optionMergeStrategies;\n  strategies.firestore = strategies.provide;\n\n  Vue.mixin({\n    created: function created () {\n      var this$1 = this;\n\n      var ref = this.$options;\n      var firestore = ref.firestore;\n      this._firestoreUnbinds = Object.create(null);\n      this.$firestoreRefs = Object.create(null);\n      var refs = typeof firestore === 'function' ? firestore.call(this) : firestore;\n      if (!refs) { return }\n      Object.keys(refs).forEach(function (key) {\n        this$1.$bind(key, refs[key]);\n      });\n    },\n\n    beforeDestroy: function beforeDestroy () {\n      for (var subKey in this._firestoreUnbinds) {\n        this._firestoreUnbinds[subKey]();\n      }\n      this._firestoreUnbinds = null;\n      this.$firestoreRefs = null;\n    }\n  });\n\n  // TODO test if $bind exist and warns\n  Vue.prototype.$bind = function (key, ref, options) {\n    if (this._firestoreUnbinds[key]) {\n      this.$unbind(key);\n    }\n    var promise = bind(\n      {\n        vm: this,\n        key: key,\n        ref: ref,\n        ops: ops\n      },\n      options\n    );\n    this.$firestoreRefs[key] = ref;\n    return promise\n  };\n\n  Vue.prototype.$unbind = function (key) {\n    this._firestoreUnbinds[key]();\n    delete this._firestoreUnbinds[key];\n    delete this.$firestoreRefs[key];\n  };\n}\n\nexport default install;\n"],"sourceRoot":""}